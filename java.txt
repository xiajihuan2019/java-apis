包的命名规则：
企业域名的反写+项目名词+模块名称

com.alibaba.double.bio

数组：
数组的定义：同一种相同数据类型的元素的集合，具有线性结构
申明：
数据类型 []数组名词=new 数据类型[长度];
int [] arr=new int[6];
int [] arrs={1,4,7,9};

访问数组：通过下标访问数组
为数组赋值
arr[1]=1;
length;属性
遍历数组（for循环）
方法：
方法的定义：
  完成某一个具体功能的代码块，从某种程度上来说，可以
  使代码得到很好的复用。


方法的修饰符  返回值类型  方法名(参数表){

  //方法体

}

public static 返回值类型  方法名(参数表){
   //方法的实现
}

返回值类型的种类：
基本数据类型
引用数据类型
void类型

方法名：遵循一般变量的命名规则
参数表：
每一个参数必须有有类型，多个参数之间必须使用“,”隔开

方法体使用两个{}花括号表示，放的具体业务实现
写在花括号里面。方法体写完以后，根据返回值类型来确定
返回什么样的值。

public  static  int  min(int[] args){
      int tmp=[args[0];
      for(int i=1;i<args.length;i++){
          if(tmp<args[i]){
            tmp=args[i];
          }
      }
      return tmp;
}

写一个方法拼接两个数组形成一个新数组

public static int[]  merger(int[] a,int[] b){

   int[] c=new int[a.length+b.length];
   //拷贝逻辑
   int k=0;
   for(int i=0;i<c.length;i++){
       if(i>a.length){
          if(k>=b.length){
            break;
          }
          c[i]=b[k];
          ++k;
         continue;
       }
        c[i]=a[i];
   }

}

编写一个函数随机打印出5不同的A-Z中的五个字符而且不能重复
char [] letters={

}


Random ran=new Random();
ran.nextInt(26);

方法的调用

方法写好以后就可以进行方法的调用，方法的调用就是实参初始化形参
的进行方法调用的过程。


public  static void m1(int a, int b){

   System.out.println(a+b);


}
public static void pp(){

  Systme.out.println("tttt");
}

public static void main(String[]args){
  int a=1;
  int b=2;
  int c=pp(1,2);
}

----------------------------------------------------------------------

面向对象：
   面向对象(Object Oriented)是软件开发方法。面向对象的概念和应用已超越了
程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台
、分布式系统、网络管理结构、CAD技术、人工智能等领域。面向对象是一种对
现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。

类：类是一系列相同对象的属性和行为的抽象，是一个模板。是一种抽象的东西，现实生活
中不存在。 封装了一系列对象的属性和行为。

对象：
现实生活中，万物皆对象，看得见，摸得着的东西都叫对象，只是每一个对象都有其所属的类。
（菜鸟一定要做到，看到对象联想的该对象所属的类，这个过程叫做抽类）

面向对象的三大特征：
1、封装
    就是把一系列对象的所具有的共同的属性和行为进行抽取出来，形成一个类，通过
    这个类封装了这些对象的属性和行为。

2、继承

3、多态

Java的类结构

public class 类名{
  //若干属性（成员变量）
  //若干行为（方法）
}
属性：是说明某一个对象的某一个特征的专有名词【成员变量】

行为：描述的是对象的某一个动作（动词）【方法】

人类：


类名：Person
属性：
   姓名  权限修饰符（public）  数据类型（String） 变量名(name)
   性别  权限修饰符（public）  数据类型（char）   变量名(gender)
   年龄  权限修饰符（public）  数据类型（int）    变量名(age)
   身高  权限修饰符（public）  数据类型（double） 变量名(height)
   体重  权限修饰符（public）  数据类型（double） 变量名(weight)
行为：
   吃饭
      方法的权限修饰符(public) 返回值类型（void）方法名eat  参数表(无参数)
   睡觉
     方法的权限修饰符(public) 返回值类型（void）方法名sleep  参数表(无参数)
   计算两个数的和
      方法的权限修饰符(public) 返回值类型（int）方法名sum  参数表(int a,int b)
类一旦创建成功，就可以通过该类创建该类的实例（对象），一旦
对象创建成功那么该对象就可以为所欲为。

创建对象的格式：
类名 对象的引用名=new 类名();

通过对象访问对象的属性和行为，Java语言里面采用
对象名.属性名  或者对象名.方法名();

注意：如果创建一个类的时候没有为类的成员变量赋值，那么
Java程序会为每一种数据类型的变量初始化值，引用类型
初始化为null,  整型初始化为0，否点型初始为0.0  boolean
初始化为false,char初始化为' '

练习：创建一个学生类
  类名  Student
  属性：
   学号（sid）
   姓名（sname）
   性别 (gender)
   专业  (majar)
   年级  (grade)
  行为：
     学习英语
     谈恋爱

     创建两个学生对象，分别访问自己的属性和行为

创建对象的实现原理：
Java程序底层是调用了类提供的构造器（构造方法）来完成对象的初始化和创建

构造器：
   作用：完成对象的初始化和创建

   （通过new 关键字调用类提供的构造器完成对象的初始化和创建）
  特点：
      修饰符类型一般是public
      没有返回值类型
      方法名称必须和类名完全一样
  注意：如果创建类的时候没有为类显示指定构造器，那么Java程序会默认创建一个无参数的构造器。
  如果一旦开发人员显示指定有参数的构造器以后，那么无参数的构造器就会失效，这时候必须显示
  申明无参数的构造器，否则编译将会失败。

  this关键字：
  使用在两个地方：
  1、普通的实例方法里面
      表示调用该普通实例方法的当前对象，也就是说，那个对象调用的该方法，那么该方法里面出现的
      this就表示那个对象（注意：this表示对象,每一个普通方法里面都有一个隐含的this）
  2、构造器里面
      a、表示利用构造器即将创建的对象
      b、表示当前类的其它构造


  getter与setter方法；
  有时候如果一个字段被private修饰那么该字段是不可以被外界
  直接访问的。如果要访问必须使用getter方法，如果要
  修改值，必须使用setter方法。
      方法命名格式：  get属性名称  set属性名称
      当时属性名称的第一个字母必须大写


对象数组：
数据类型 []数组名=new 数据类型[长度];

int [] arrs=new int[10];

Person []ps=new Person[10];

继承：
  继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，
就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具
有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义
某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子
类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类
别的行为在编译期就已经决定，无法在执行期扩充。
那么如何使用继承呢？用extends关键字来继承父类。
如上面A类与B类，当写继承语句时， class A类 extends B类{ } 其中A类是子类，B类是父类。


 java语言的继承，可以通过extends关键字实现子类继承父类的关系，注意Java
 不支持多继承。  A extends B

继承的好处：
  1、重写父类的方法
  2、扩展子类的独有的方法或者属性
  3、可以使得代码得到良好的复用

继承的特点：
1、重写基类的方法
2、扩展子类自己独有的方法或者属性

专业的说法:
    重写基类，扩展子类


 补充 ： 封装会满足 has a的关系  继承满足 is  a的关系


tip:如果一个属性或者一个方法被 protected修饰，那么该属性一定可以
被子类继承 ，private修饰的不能被子类继承
 public class Student{

   protected int sid;
   protected String sname;
   protected int age;
   protected char gender;
   protected double weight;
   protected double height;

   protected void studyEnglish(){
       System.out.println("学习英语");
   }

   protected  int cal(int a,int b){

      return  a+b;
   }

}

public class PrimaryStudent extends Student{
    public String redhat;
    public void playBallOfgalass(){
      Sysout.out.println("打弹珠");
    }
    protected void studyEnglish(){
          System.out.println("学习小学英语");
      }


}
public class MiddleStudent extends Student{

    public void  fighting(){
      System.out.println("打群架");
    }
}
public class CollegeStudent extends Student{
    public String major;
    public  void love(){
         System.out.println("谈恋爱");
    }

     protected void studyEnglish(){
       System.out.println("学习四六级英语");
   }


    protected  int cal(int a,int b){
      System.out.println("计算微积分");
      return  a*b;
   }

}


重写的规则：
满足两同，两小，一大
两同：
   子类重写父类的方法的方法名和参数列表必须和父类方法的方法名和
   参数列表必须完全一样
两小：
   子类的返回值类型必须小于或者等于父类的方法的返回值类型，子类
   方法抛出的异常类型一样必须小于或者等于父类方法抛出的异常类型
一大：
    子类方法的权限修饰符的权限必须大于或者等于父类方法的修饰符权限。


    super关键字
    1)使用在子类实例方法中，可以使用super.方法名的形式
    调用父类的方法
    2)是在构造器里面，表示调用父类的构造器初始化当前创建的对象


权限修饰符：

修饰符        本类          同包类       子类           其它
public        能            能           能             能
protected     能            能           能             不能
默认修饰符     能            能           不能           不能
private       能            不能         不能           不能
------------------------------------------------------------------------------------------
包：
 作用：区分两个同名的类
 命名方式：
    企业域名+项目名+模块名称
    com.alibaba.duble.rpc

导包：
使用import关键字导入包
import 包名.类名
import 包名.*
使用包的全路径

--------------------------------------------------------------------
多态：把一种事物的多种表现形式叫做多态，Java语言里面把一个类拥有不同的子类叫做
这个类的多态

官方解释：
多态指同一个实体同时具有多种形式。它是面向对象程序设计（OOP）的一个重要特征。
如果一个语言只支持类而不支持多态，只能说明它是基于对象的，而不是面向对象的。
C++中的多态性具体体现在运行和编译两个方面。运行时多态是动态多态，其具体引用
的对象在运行时才能确定。编译时多态是静态多态，在编译时就可以确定对象使用的形式。
多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，
可以通过指向基类的指针，来调用实现派生类中的方法。


抽象类：
抽象类是一个半成品，该类必须进一步加工才能使用


Java语言的抽象类：
抽象类使用abstract关键字修饰，抽象类里面可以含有抽象方法也有
实例方法，类方法，成员变量等。

格式：
public abstract class 类名{
   //若干成员变量
   //若干方法
   //若干抽象方法
}

抽象方法：
方法的修饰符必须加上abstract,并且抽象方法没有方法体。
比如；
public abstract void m();


局部变量
  把在方法参数列表，方法体里面定义的变量都是局部变量，局部变量的
  生命周期随着方法调用的结束而结束。
全局变量
非局部变量就是全局变量。


final关键字：
1)被final关键字修改的不能被子类继承
2）被final修饰的方法不能被子类重写
3)被final修饰的变量不能被再次的赋值

 补充：函数的可变形参
 数据类型 ... 参数名称;
常量
Java语言里面的常量标注写法：
public static final 数据类型 常量名="常量值";
pubic static final String DESC="xxxx";

接口：接口是一个公共的标准，一个约束。

java里面的接口，使用关键字interface修饰。

格式：

public interface 接口名称{
   //若干抽象方法
   //常量

}
注意：JDK1.8之前，接口里面只能有抽象方法和常量
类实现接口使用implements关键字,接口与接口之间可以继承，一个类
可以实现多个接口（这就弥补了Java单继承的缺陷）

抽象类普通类的区别：
相同点：
都可以含有普通属性和方法
不同点：
抽象类必须使用abstract修饰，抽象类可以含有抽象方法。抽象类不能
实例化。

抽象方法和实例方法的区别：
相同点：
   都有权限修饰符 返回值类型 参数列表
不同点：
   抽象方法必须使用abstract关键字修饰，而且没有方法体，并且
   只出现抽象类和接口中。

-----------------------------------------------------------------
内部类：
静态内部类：
 创建静态内部类的对象格式为：
 外部类类名.静态内部类类名 对象引用名称=new 静态内部类构造器;
非静态内部类：
   创建外部类对象  对象引用名称=外部类对象.new 非静态内部类的构造器;

   注意：非静态内部类不能含有静态资源。


匿名内部类：

没有类名的类叫做匿名内部类，匿名内部类一定是某一个类，或者抽象，接口的子类。
假设一个类只需要使用一次，那么就可以使用匿名内部类。

函数式接口：
  接口里面只有一个抽象方法的接口叫做函数式接口，这是JDK1.8以上版本
  支持的，而且可在接口之上使用@FunctionalInterface注解修饰
  一个接口，表示该接口是一个函数式接口，函数式接口支持lamda表达式
  创捷接口子类实例。 除此以外JDK1.8还新增了接口的约定，1.8之前接口
  里面只能包含抽象方法和常量，1.8以后接口里面可以包含静态方法和默认
  方法。


https://www.cnblogs.com/yumiaoxia/p/9021317.html
Java 8新增的Lambda表达式
一. 表达式入门

Lambda表达式支持将代码块作为方法参数，lambda表达式允许使用更简洁的代码来创建只有一个抽象方法的接口（这种接口被称为函数式接口）的实例，相当于一个匿名的方法。

1.1 Lambda表达式入门

Lambda表达式由三部分组成：

形参列表。形参列表允许省略形参类型，如果只有一个参数，那么形参列表的圆括号也可以删除。
箭头（->）。
代码块。Lambda表达式需要返回值，如果Lambda表达式代码块只有一条返回语句，则可以省略return关键字和包裹这条语句的花括号，表达式自动返回这条语句。
Lambda表达式作为参数使用时，相当于一个任何类型的对象。

1.2 Lambda表达式与函数式接口

Lambda 表达式的类型，也被称为“目标类型”，Lambda表达式的目标类型必须是函数式接口。

函数式接口代表只包含一个抽象方法的接口，可以包含多个默认方法，静态方法，但只能声明一个抽象方法。

由于Lambda表达式的结果就是被当成对象，因此程序完全可以使用Lambda表达式进行赋值。例如

Runnable r = ()->{
for( int i =0;i <100;i++)
{
System.out.println();
}
};
 1.3 Lambda的使用方式

将Lambda表达式赋值给函数式接口类型变量
将Lambda表达式作为函数式接口类型的参数传给某个方法
使用函数时接口对Lambda表达式进行强制类型转换。
例如上面代码可改成

Object obj =(Runnable) ()->{
for( int i =0;i <100;i++)
{
System.out.println();
}
};
Java8在java.util.function包下定义了大量函数式接口，典型的有四类

XxxFunction。apply()抽象方法对参数进行处理转换，然后返回一个新的值。
XxxConsumer。accept()抽象方法也是对参数进行转换处理，不返回处理结果。
XxxxPredicate。test()抽象方法对参数进行判断，返回一个boolean值。
XxxSupplier。getAsXxx()抽象方法没有参数，会按某种逻辑算法返回一个数据。
1.4 方法引用与构造器引用

    如果Lambda表达式代码块只有一条代码，还可以在代码块中使用方法引用和构造器引用

Lambda表达式支持的方法引用和构造器引用
种类	实例	说明	对应的Lambda表达式
引用类方法	类名::类方法	函数式接口被实现方法的参数传给该类方法作为参数	(a,b,...)->类名.类方法(a,b,...)
引用特定对象的类方法	特定对象::实例方法	函数式接口被实现方法的参数传给该方法作为参数	(a,b,...)->特定对象.实例方法(a,b,...)
引用某类对象的实例方法	类名::实例方法	函数式接口中被实现方法的第一个参数作为调用者，后面的参数全部传给该方法作为参数	(a,b,...)->a.实例方法(a,b,...)
引用构造器	类名::new	函数式接口被实现方法的参数传给该构造器作为参数


块；
静态代码块：
   static{
     //语句块

   }
  //用于初始化静态资源
普通代码块：
   //不常用，对象创建一次，普通代码块就执行一次
public class 类名{

   //静态代码块
   //普通代码块
   //静态方法
   //普通实例方法
   //属性
}

讨论：静态代码块 普通代码块 构造器的执行流程

如果只有一个类的时候，静态代买快优先执行，之后再执行普通代码块
在执行构造器。（静态代码块只会执行一次）
如果类存在继承关系（Object除外）
先执行父类的静态代码块，再执行子类的静态代码块，再执行父类的普通
代码块，再执行父类的构造器，再执行子类的普通代码块，在执行子类的
构造器。


Maven
Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，
报告和文档的项目管理工具软件。

安装maven
apach官网下载Maven
安装Maven

配置中央仓库

配置maven环境变量

电脑--->属性---->高级设置---->环境变量--->系统环境变量

Idea集成Maven


pom文件

maven工程的项目类型主要有3种：（打包方式）
1)pom工程（聚合工程）
   管理所有子工程，比如对子工程的jar包版本依赖管理，插件管理等
   不需要src目录
2)jar工程(默认的)
   maven只会打包所有的.java文件不会打包配置文件
3)war工程
  war就相当于标准的Maven文件。
  会打包所有的文件，包括配置文件
可以使用packaging节点进行打包
<packaging>war</packaging>

约定由于配置，配置优于编码

properties节点：
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>
可以自定义节点名称来控制依赖的版本号

dependencies:节点
该节点下有许多的dependency节点，
dependency节点表示一个依赖（一个坐标）

dependency节点：
<dependency>
          <groupId>mysql</groupId>
          <artifactId>junit</artifactId>
          <version>4.12</version>
</dependency>
推荐大家使用一个网址去找节点坐标
：https://  mvnrepository.com
dependencyManagement节点：
该节点主要是管理所有子项目的依赖节点，而且该节点下只能由
dependecies节点。 使用dependencyManagement管理的节点依赖
不会导入相应的依赖，而需要在子项目里面去导入相应的依赖，子项目
不需要写明版本号

-----------------------------------------------------------------------------------------------------------











